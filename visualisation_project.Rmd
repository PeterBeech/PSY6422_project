---
title: "**Overwatch League 2019 Visualization & Analysis**"
output: 
  html_document:
    fig_width: 10
    df_print: paged
---
```{r echo = FALSE, results = FALSE}
install.packages("renv")
library(renv)
renv::restore()
```
```{r echo = FALSE, warning = FALSE, message = FALSE, error = FALSE, out.width = "65%", fig.align = "center"}
library(here)
logo <- here("figs","OWL.png")
knitr::include_graphics(logo)
```
  
## Background

Overwatch is a 6-a-side online team-based first-person shooter (fps) game in which two teams battle to achieve victory over each other by collectively competing to complete a set objective. Players on each team pick a unique character or **'hero'** (limited to one each per team), from a roster of 30 (as of 2019).

Characters are categorized into 3 groups depending upon their designed role in a team:  
**Tanks** survive longer and protect teammates from damage,  
**Healers** restore the health of teammates, and  
**Damage** are designed to be more mobile and deal higher damage to enemy heroes.

## Data Origins and Research Questions

The dataset was obtained from [Overwatch League Statslab](https://www.overwatchleague.com/en-us/statstab) and contains in-game stat data collected during the **Overwatch league (OWL)** 2019 professional esports tournament; including a record of how long each hero was played for by each player in each tournament match, which indicates the popularity of the character in the **'meta'** - the generally agreed upon most effective winning strategy.

The game's esports scene reached peak popularity around 2018-19, during which time a specific composition of heroes, termed **GOATS** (after the North American team which discovered it), was found to be most optimal and became the popular choice for professional teams.
This composition composed of 3 tanks, and 3 healers, neglecting mobile dps characters in favor of raw survivability. This was controversial as most of these heroes required less skill at aiming - a central part of most fps games.

The dominance of this composition triggered a wave of attempts by the developers of the game to decrease the power of the heroes within GOATS during 2019, culminating with the introduction of a 'role lock' in 2020; whereby, each team was limited to picking 2 heroes from each group. The game experienced a sudden decline in popularity going into 2020, believed to be primarily due to this change, thus it is important to review if this was indeed a necessary change, or a bad decision by the developers.

#### Project Aim

The primary aim of this project is to visualize the distribution of hero popularity, and formation of a meta during the **OWL** 2019 tournament, in order to see how big of an issue the GOATS composition was to hero pick variety.

*note: the acronyms OWL and GOATS are unrelated to the animals*

### Data Description:

A codebook for this project is located at /codebook.txt, and a description of csv data column titles is located in /data/rawdata/datasource.txt 

## Data Preparation

### Loading Packages

The renv package was used to store versions of packages used at the time of coding, allowing the visualisation to function independent of future updates to packages.

Package versions used in this project are listed within the file renv.lock

```{r loadlib, echo = TRUE, results = 'hide', warning = FALSE, message = FALSE}
knitr::opts_chunk$set(echo = TRUE, results = 'hide', warning = FALSE, error = FALSE, message = FALSE, rows.print = 5, fig.align = "center")
renv::restore()

#Import packages
library(tidyverse)
library(ggplot2)
library(here)
library(readr)
library(showtext)
```

The dataset consists of three separate csv files, so the initial step was to combine these into a single dataframe.

```{r results = TRUE}
#Read raw data files and combine into a single csv file
combinedData <- list.files(path = here("data", "rawdata"),  
                           pattern = "*.csv", full.names = TRUE) %>% 
  lapply(read_csv) %>%                                      
  bind_rows                                                 

#Save combined data set
combinedData_FileName = paste(here("data"), "/phs_2019_combined.csv", sep = "")   
write.csv(combinedData, combinedData_FileName)   #Write dataset to new .csv in /data

combinedData
```

The combined dataset contains a large amount of unnecessary information; thus, was cleaned by extracting required data to a new data frame to increase readability and decrease data frame processing time.

```{r}
#Obtain data to plot hero playtime
heroData <- combinedData[combinedData$hero != "All Heroes", ]   #Remove rows with "All Heroes" in hero column
  
playTimeData <- heroData[heroData$stat_name == "Time Played", ] %>%   #Remove rows without "Time Played" in stat_name column
  group_by(hero) %>%   #Sum playtime for each hero
  summarise(play_time = sum(stat_amount)) %>% 
  ungroup()

#Creates the function clean_pt; which, reorders and converts play time data into hours
clean_pt <- function(df){  
    df %>%      
    arrange(., desc(play_time)) %>%                                   #Arrange data by descending value of play_time
    mutate(play_time = play_time/3600) %>%                            #Convert play_time from seconds to hours and round to the nearest whole number
    mutate(rounded_play_time = round(play_time)) %>% 
    transform(rounded_play_time = as.character(rounded_play_time))
}
  
playTimeData <- clean_pt(playTimeData) 
```

## Visualisation

A bar chart was most appropriate for the data, and is simple and commonly used, increasing ease of interpreting the data

Clarity and appeal were achieved using a minimalistic and clean design

### Colours

Colours of bars correspond to colours of the heroes within the game, increasing the glance value for those familiar with the game (And, those most likely to be interested in the data)

### Custom Text

A custom text was imported and applied to the visualisation using the showtext package. The font is similar to fonts used within the game, making the visualisation appear more professional and/or official.

This introduced an issue with preserving custom fonts when saving an image of the plot, which was fixed by plotting to a windows graphics device using windows() before saving this output as a .png. 
However, I am unable to test whether this fix would work on other operating systems, as I currently only have access to windows OS. For these OS, the quartz() command is a possible fix to replace windows().

```{r}
#Aesthetics for graph
  #Retrieve colour associated with each hero and add to playTimeData df as column hero_colour
heroColourLocation <- here("data", "hero_colours.csv")
heroColourData <- read.csv(file = heroColourLocation, encoding = "UTF-8")
colnames(heroColourData)[1] <- gsub('^.........','',colnames(heroColourData)[1])   #Fix error with imported column name

#Creates the function add_colour; which, for each hero in the dataframe, writes the related colour hex value to a column called hero_colour
add_colour <- function(df){
i = 0
  for (h in df$hero){   
    i = i + 1
    hrow <- which(heroColourData$hero == h)
    df$hero_colour[i] <- paste(heroColourData$hex_value[hrow])
  }
  df
}

playTimeData <- add_colour(playTimeData)
```

```{r}
#Load new custom font for showtext package
font_add_google(name = "Bebas Neue", family = "Bebas Neue")
showtext_auto()
```

```{r}
#Define graph aesthetic variables
backgroundColour = "white"
textColour = "#5c5c5c"
textColourFaded = "#5c5c5c8a"
barLabelSize = 11
```

### Bar Plot

```{r results = TRUE}
#Define data to plot
nheros <- 15:1   #Define number of heroes to show on graph
hpt <- ggplot(playTimeData[nheros,], aes(x = hero, y = play_time, fill = hero))   #Assign hero play time plot data to a variable

#Align text bar label with numerical bar label. Two labels are used to allow font size difference
i = 0
hourLabel <- c(0) 
for (i in nheros){   #If playtime has more than 2 digits, increases spacing of HOURS label to align with numerical bar label
  hourLabel[i] <- "HOURS"
  if (playTimeData$play_time[i] > 99){
    hourLabel[i] <- "  HOURS"
  }
}

playTimeData
```

```{r}  
#Plot graph and customize various plot aesthetics
graph <- hpt +  
  geom_bar(stat = "identity", mapping = aes(x = hero, y = playTimeData$play_time[1]), fill = "#e6e6e6") +
  geom_bar(stat = "identity", show.legend = FALSE) +
  geom_text(aes(label = rounded_play_time), y = 2, family = "Bebas Neue", colour = "white", size = barLabelSize, hjust = 0) +
  geom_text(aes(label = rev(hourLabel)), y = 2, family = "Bebas Neue", colour = "white", size = 6.3, hjust = -0.80, vjust = 0.85) +
  scale_x_discrete(limits = playTimeData$hero[nheros]) +
  scale_y_continuous(limits = c(0, (playTimeData$play_time[1] + 20)), expand = c(0, 0)) +
  xlab("HERO") +
  ylab("PLAY TIME (hours)") +
  labs(title = "Overwatch League Character Usage", subtitle = "by playtime during OWL 2019 stages 1-3", size = 40) +
  theme_bw() +
  coord_flip() +
  scale_fill_manual(values = playTimeData$hero_colour, limits = playTimeData$hero) +
  theme(panel.border = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(), 
        axis.line = element_line(colour = backgroundColour),
        plot.background = element_rect(fill = backgroundColour),
        panel.background = element_rect(fill = backgroundColour),
        text = element_text(family = "Bebas Neue", colour = textColour),
        plot.title = element_text(size = 35, colour = "#505050"),
        plot.subtitle = element_text(size = 25, colour = textColourFaded),
        axis.title.x = element_text(size = 30, margin = margin(t=20), colour = textColourFaded, hjust = 0.42),
        axis.title.y = element_text(size = 40, margin = margin(r=19), colour = "#5c5c5c4f"),
        axis.ticks.x = element_line(colour = textColourFaded, size = 0.8),
        axis.ticks.y = element_blank(),
        axis.ticks.length.x = unit(0.2, "cm"),
        axis.ticks.length.y = unit(0.3, "cm"),
        axis.text.x = element_text(colour = textColourFaded, size = 16, angle = 55, vjust = 0.9, hjust = 0.95),
        axis.text.y = element_text(colour = textColour, size = 24))
```

```{r results = TRUE, fig.width = 6, fig.height = 5, out.width = "150%"}
#Display graph
print(graph)
```

### Saving Plot



```{r eval = FALSE}
#Save plot to figs folder
windows(width = 1200, height = 1200)   #Open windows graphics device
print(graph)
dev.print(file = here("figs", "PlayTimeGraph.png"), device = png, width = 1200, height = 1200)

  
  #Possible alternate fix for mac operating systems to preserve font
  quartz(width = 1200, height = 1200)
  print(graph)
  quartz_save(file = here("figs", "PlayTimeGraph.png"), type = "png", dpi = 300)
```

## Conclusion Part 1

### Interpretation

The plot shows a notable difference between the play time of the top 6 heroes compared to the rest of the 30-hero roster

### Possible follow-ups or extensions

An animated plot could accommodate looking at changes in hero popularity distribution over the duration of 2019 OWL, and the effect of title matches (finals) on hero popularity distribution.

## Animated Plot

Because the data does not smoothly correlate between states, I decided not to reorder the plot for each state to reduce confusion in the visualization. This has the downside of making it harder to view the specific popularity ranking of each hero. Similarly, a line graph may  However, the main purpose of this visualization is to view the formation of a meta, and size of disparity between hero popularities.

```{r results = TRUE}
library(gganimate)
library(gifski)

#Obtain data to plot play time by season from combined dataset using previously created functions
stagePlayTimeData <- heroData[heroData$stat_name == "Time Played", ] %>% 
  group_by(stage, hero) %>% 
  summarise(play_time = sum(stat_amount)) %>% 
  ungroup() %>% 
  clean_pt() %>% 
  add_colour()

#Calculate total playtime in each season
stageTime <- heroData[heroData$stat_name == "Time Played", ] %>% 
  group_by(stage) %>% 
  summarise(play_time = sum(stat_amount)) %>% 
  ungroup() %>% 
  clean_pt()

#Divide hero play times by total playtime for the corresponding season, giving a percentage of total season play time the hero was used
j = 0
for (s in stagePlayTimeData$stage){
  j = j + 1
    srow <- which(stageTime$stage == s)
    stagePlayTimeData$percent_play_time[j] = (stagePlayTimeData$play_time[j] / stageTime$play_time[srow]) * 100 * 6 
}

#Define data to plot
shpt <- ggplot(stagePlayTimeData, aes(x = hero, y = percent_play_time, fill = hero))

stagePlayTimeData
```

```{r results = TRUE, dpi = 300}
#Plot graph and customize various plot aesthetics
staticAnimGraph <- shpt +
  geom_bar(stat = "identity", show.legend = FALSE) +
  scale_y_continuous(limits = c(0, 100), expand = c(0, 0)) +
  scale_x_discrete(limits = rev) +
  xlab("HERO") +
  ylab("PLAY TIME (hours)") +
  labs(title = "Overwatch League Character Usage", subtitle = ("playtime during {closest_state}"), size = 40) +
  theme_bw() +
  coord_flip() +
  scale_fill_manual(values = playTimeData$hero_colour, limits = playTimeData$hero) +
  geom_vline(xintercept = seq(1.5, length = 32), lwd = 2, colour = "white") +
  geom_vline(xintercept = seq(-1.5, length = 32), lwd = 2, colour = "white") +
  theme(panel.border = element_blank(), 
        panel.grid.major = element_blank(), 
        panel.grid.minor = element_blank(),
        axis.line = element_line(colour = backgroundColour),
        plot.background = element_rect(fill = backgroundColour),
        panel.background = element_rect(fill = "#e6e6e6"),
        text = element_text(family = "Bebas Neue", colour = textColour),
        plot.title = element_text(size = 30, colour = "#505050", vjust = 2),
        plot.subtitle = element_text(size = 20, colour = textColourFaded),
        axis.title.x = element_text(size = 30, margin = margin(t=20), colour = textColourFaded, hjust = 0.42),
        axis.title.y = element_text(size = 40, margin = margin(r=19), colour = "#5c5c5c4f"),
        axis.ticks.x = element_line(colour = textColourFaded, size = 0.8),
        axis.ticks.y = element_blank(),
        axis.ticks.length.x = unit(0.2, "cm"),
        axis.ticks.length.y = unit(0.3, "cm"),
        axis.text.x = element_text(colour = textColourFaded, size = 16, vjust = 0.9, hjust = 0.85),
        axis.text.y = element_text(colour = textColour, size = 20)) +
        transition_states(stage, transition_length = 2, state_length = 2)

#Render the animated graph as gif and save to figs folder
animate(staticAnimGraph, 200, fps = 20, width = 900, height = 900,
        renderer = gifski_renderer(here("figs", "SeasonPlayTimeGraph.gif")))
```

## Conclusion Part 2

### Interpretation

Additionally the difference between play times of the top 6 heroes and the other 24 seems larger in title matches for stages 1 and 2, indicating either less experimentation by teams, or that teams using the meta GOATS composition were the ones that reached the finals, suggesting it's strength over the other compositions.

### Possible Follow-ups or Extensions

Hero pick distribution could be plotted against viewer amounts for the respective stages, investigating a possible link between game popularity and hero pick variety.

## Code Readability

Functions

Order

Indents, comments, structure, rationale explained

Variables (appropriate and clear names)

## References
